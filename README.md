# Modern CPP Training

## This is training code and material taught during the Modern CPP training in KPIT Technologies. This includes the following topics:
    - C++11
    - C++14
    - C++17

## Mainly, training focussed on the following topics:
    - Modern C++ features
    - STL
    - Multithreading
    - Smart Pointers
    - Exception Handling
    - Lambda Expressions
    - Regular Expressions
    - C++11/14/17 features

## Also, the training includes the following tools:
    - CMake
    - Google Test
    - Doxygen
    - Valgrind
    - GDB
    - Clang-Format
    - Clang-Tidy
    - CppCheck

# Constructor Delegation
- A constructor can call another constructor of the same class using the `this` pointer.
- This is called constructor delegation.
- It is useful when you want to provide default values for some parameters.

```cpp
#include <iostream>
class A
{
    int x;
    int y;
public:
    A(int x, int y) : x(x), y(y)
    {
        std::cout << "Parameterized Constructor" << std::endl;
    }
    A() : A(0, 0) // Delegating constructor
    {
        std::cout << "Default Constructor" << std::endl;
    }
};
int main()
{
    A a1(10, 20);
    A a2;
    return 0;
}
```
# Uniform Initialization in Modern C++
- In C++11, a new way of initializing objects was introduced.
- It is called uniform initialization.
- It uses curly braces to initialize objects.
- It is also called brace initialization.
- It is more consistent and prevents narrowing conversions.
- It is also used to initialize arrays and structures.

```cpp
#include <iostream>
class A
{
    int x;
    int y;
public:

    A(int x, int y) : x{x}, y{y} // Uniform Initialization
    {
        std::cout << "Parameterized Constructor" << std::endl;
    }
    A() : A{0, 0} // Delegating constructor
    {
        std::cout << "Default Constructor" << std::endl;
    }
};
int main()
{
    A a1{10, 20}; // Uniform Initialization
    A a2{}; // Uniform Initialization
    return 0;
}
```
# Special Member functions in C++
- Special member functions are the member functions that are automatically generated by the compiler if they are not explicitly defined.
- They are:
    - Default Constructor
    - Copy Constructor
    - Copy Assignment Operator
    - Destructor
    - Move Constructor
    - Move Assignment Operator
- These functions are generated by the compiler if they are not explicitly defined.
- They are generated based on the need of the class.
- We can explicitly define them if we want to customize their behavior.

````cpp
#include <iostream>
class A
{
    int x;
    int y;
public:
    A()=default; // Default Constructor
    A(const A&)=default; // Copy Constructor
    A& operator=(const A&)=default; // Copy Assignment Operator
    ~A()=default; // Destructor
    A(A&&)=default; // Move Constructor
    A& operator=(A&&)=default; // Move Assignment Operator
};
int main()
{
    A a1; // Default Constructor
    A a2(a1); // Copy Constructor
    A a3;
    a3=a2; // Copy Assignment Operator
    return 0;
}
````
# Delete Keyword in C++
- In C++, we can delete the special member functions using the `delete` keyword.
- It is used to explicitly delete the special member functions.
- It is used to prevent the compiler from generating the special member functions.
- It is used to prevent the objects of the class from being copied or assigned.

```cpp
#include <iostream>
class A
{
    int x;
    int y;
public:
    A()=delete; // Default Constructor
    A(const A&)=delete; // Copy Constructor
    A& operator=(const A&)=delete; // Copy Assignment Operator
    ~A()=delete; // Destructor
    A(A&&)=delete; // Move Constructor
    A& operator=(A&&)=delete; // Move Assignment Operator
};
int main()
{
    A a1; // Error
    A a2(a1); // Error
    A a3;
    a3=a2; // Error
    return 0;
}
```
# Default Keyword in C++
- In C++, we can default the special member functions using the `default` keyword.
- It is used to explicitly default the special member functions.
- It is used to allow the compiler to generate the special member functions.
- It is used to allow the objects of the class to be copied or assigned.

```cpp

#include <iostream>
class A
{
    int x;
    int y;
public:

    A()=default; // Default Constructor
    A(const A&)=default; // Copy Constructor
    A& operator=(const A&)=default; // Copy Assignment Operator
    ~A()=default; // Destructor
    A(A&&)=default; // Move Constructor
    A& operator=(A&&)=default; // Move Assignment Operator
};
int main()
{
    A a1; // Default Constructor
    A a2(a1); // Copy Constructor
    A a3;
    a3=a2; // Copy Assignment Operator
    return 0;
}
```
# Composition in C++
- In C++, composition is a way to combine objects of different classes.
- It is used to create a complex object by using simple objects.
- It is used to create a complex object by using the objects of other classes.
- Composition is a "has-a" relationship rather than an "is-a" relationship.

```cpp
#include <iostream>
class Address
{
    std::string city;
    std::string state;
    std::string country;
public:
    Address(std::string city, std::string state, std::string country) : city(city), state(state), country(country)
    {
    }
    void display()
    {
        std::cout << city << " " << state << " " << country << std::endl;
    }
};
class Employee
{
    int id;
    std::string name;
    Address* address; // Composition
public:
    Employee(int id, std::string name, Address* address) : id(id), name(name), address(address)
    {
    }
    void display()
    {
        std::cout << id << " " << name << std::endl;
        address->display();
    }
};
int main()
{
    Address a1("New York", "New York", "USA");
    Employee e1(101, "John", &a1);
    e1.display();
    return 0;
}
``` 
# Aggregation in C++
- In C++, aggregation is a way to combine objects of different classes.
- It is used to create a complex object by using simple objects.
- It is used to create a complex object by using the objects of other classes.
- Aggregation is a "has-a" relationship rather than an "is-a" relationship.
- Aggregation is a weak relationship.

```cpp
#include <iostream>
class Address
{
    std::string city;
    std::string state;
    std::string country;
public:
    Address(std::string city, std::string state, std::string country) : city(city), state(state), country(country)
    {
    }
    void display()
    {
        std::cout << city << " " << state << " " << country << std::endl;
    }
};
class Employee
{
    int id;
    std::string name;
    Address address; // Aggregation
public:
    Employee(int id, std::string name, Address address) : id(id), name(name), address(address)
    {
    }
    void display()
    {
        std::cout << id << " " << name << std::endl;
        address.display();
    }
};
int main()
{
    Address a1("New York", "New York", "USA");
    Employee e1(101, "John", a1);
    e1.display();
    return 0;
}
```
# Inheritance in C++
- In C++, inheritance is a way to create a new class from an existing class.
- It is used to create a new class from an existing class.
- It is used to create a base class and a derived class.
- It is used to create a parent class and a child class.
- It is used to create a super class and a sub class.
- It is used to create a general class and a specific class.

```cpp
#include <iostream>
class A
{
    int x;
    int y;
public:
    void display()
    {
        std::cout << "Display of A" << std::endl;
    }
};
class B : public A // Inheritance
{
    int z;
public:
    void display()
    {
        std::cout << "Display of B" << std::endl;
    }
};
int main()
{
    B b;
    b.display(); // Display of B
    b.A::display(); // Display of A
    return 0;
}
```
# Casting in C++
- In C++, casting is a way to convert one data type to another data type.
- It is used to convert one data type to another data type.
- It is used to convert the base class pointer to the derived class pointer.
- It is used to convert the derived class pointer to the base class pointer.
- It is of four types:
    - Static Cast
    - Dynamic Cast
    - Const Cast
    - Reinterpret Cast

```cpp
#include <iostream>
class A
{
public:
    void display()
    {
        std::cout << "Display of A" << std::endl;
    }
};
class B : public A
{
public:
    void display()
    {
        std::cout << "Display of B" << std::endl;
    }
};
int main()
{
    B b;
    A* a = &b; // Implicit Conversion
    B* b1 = static_cast<B*>(a); // Static Cast
    b1->display();
    A* a1 = static_cast<A*>(&b); // Static Cast
    a1->display();
    return 0;
}
```
## Static Cast
- It is used to convert the data type to another data type.
- It is used to convert the base class pointer to the derived class pointer.
- It is used to convert the derived class pointer to the base class pointer.
- It is used to convert the data type to the void pointer.
- It is used to convert the void pointer to the data type.
- It is used to convert the data type to the integral type.
- It is used to convert the integral type to the data type.
```cpp
#include <iostream>
int main()
{
    int x = 10;
    double y = static_cast<double>(x); // Static Cast
    std::cout << y << std::endl;
    return 0;
}
```
## Dynamic Cast
- It is used to convert the base class pointer to the derived class pointer.
- It is used to convert the derived class pointer to the base class pointer.
- It is used to convert the data type to another data type.
- It is used to convert the data type to the void pointer.
- It is used to convert the void pointer to the data type.
```cpp
#include <iostream>
class A
{
public:
    virtual void display()
    {
        std::cout << "Display of A" << std::endl;
    }
};
class B : public A
{
public:
    void display()
    {
        std::cout << "Display of B" << std::endl;
    }
};
int main()
{
    A* a = new B();
    B* b = dynamic_cast<B*>(a); // Dynamic Cast
    b->display();
    return 0;
}
```
## Const Cast
- It is used to remove the constness of the variable.
- It is used to add the constness to the variable.
- It is used to convert the data type to another data type.
- It is used to convert the data type to the void pointer.
- It is used to convert the void pointer to the data type.
```cpp
#include <iostream>
int main()
{
    const int x = 10;
    int* y = const_cast<int*>(&x); // Const Cast
    *y = 20;
    std::cout << x << std::endl;
    return 0;
}
```
## Reinterpret Cast
- It is used to convert the data type to another data type.
- It is used to convert the data type to the void pointer.
- It is used to convert the void pointer to the data type.
- It is used to convert the pointer to the integral type.
- It is used to convert the integral type to the pointer.
```cpp
#include <iostream>
int main()
{
    int x = 10;
    int* y = &x;
    int z = reinterpret_cast<int>(y); // Reinterpret Cast
    std::cout << z << std::endl;
    return 0;
}
```
# Two types of casting
- Implicit Casting
- Explicit Casting
## Implicit Casting
- It is done by the compiler automatically.
- It is done when the data type is compatible.
- It is done when the data type is smaller to larger.
- It is done when the data type is larger to smaller.
- It is done when the data type is signed to unsigned.
- It is done when the data type is unsigned to signed.
## Explicit Casting
- It is done by the programmer explicitly.
- It is done when the data type is not compatible.
- It is done when the data type is larger to smaller.
# Polymorphism and Casting in C++
- In C++, polymorphism is a way to perform a single action in different ways.
- It is used to create a base class and a derived class.
- It is used to create a parent class and a child class.
- It is used to create a super class and a sub class.
- It is used to create a general class and a specific class.
- We can cast the base class pointer to the derived class pointer using the `dynamic_cast` operator and the `virtual` function, this is called runtime polymorphism also it is called late binding.
- We can cast the base class pointer to the derived class pointer using the `static_cast` operator, this is called compile-time polymorphism also it is called early binding.
## Upcasting
- It is used to convert the derived class pointer to the base class pointer.
- It is used to convert the derived class reference to the base class reference.
- It is used to convert the derived class object to the base class object.
- It is used to convert the derived class pointer to the base class pointer using the `static_cast` operator.
- It is used to convert the derived class reference to the base class reference using the `static_cast` operator.
- It is used to convert the derived class object to the base class object using the `static_cast` operator.
```cpp
#include <iostream>
class A
{
public:
    virtual void display()
    {
        std::cout << "Display of A" << std::endl;
    }
};
class B : public A
{
public:
    void display()
    {
        std::cout << "Display of B" << std::endl;
    }
};
int main()
{
    B b;
    A* a = static_cast<A*>(&b); // Upcasting
    a->display();
    return 0;
}
```
## Downcasting
- It is used to convert the base class pointer to the derived class pointer.
- It is used to convert the base class reference to the derived class reference.
- It is used to convert the base class object to the derived class object.
- It is used to convert the base class pointer to the derived class pointer using the `dynamic_cast` operator.
- It is used to convert the base class reference to the derived class reference using the `dynamic_cast` operator.
- It is used to convert the base class object to the derived class object using the `dynamic_cast` operator.
```cpp
#include <iostream>
class A
{
public:
    virtual void display()
    {
        std::cout << "Display of A" << std::endl;
    }
};
class B : public A
{
public:
    void display()
    {
        std::cout << "Display of B" << std::endl;
    }
};
int main()
{
    A* a = new B();
    B* b = dynamic_cast<B*>(a); // Downcasting
    b->display();
    return 0;
}
```
# Virtual Function in C++
- In C++, a virtual function is a member function of the base class.
- It is used to provide a specific implementation in the derived class.
- It is used to provide a common interface to the base class and the derived class.
- It is used to provide a common interface to the parent class and the child class.
- It is used to provide a common interface to the super class and the sub class.
- It is used to provide a common interface to the general class and the specific class.
- It is used to achieve runtime polymorphism.
- It is used to achieve late binding.
```cpp
#include <iostream>
class A
{
public:
    virtual void display() // Virtual Function
    {
        std::cout << "Display of A" << std::endl;
    }
};
class B : public A
{
public:
    void display() // Overriding
    {
        std::cout << "Display of B" << std::endl;
    }
};
int main()
{
    A* a = new B();
    a->display(); // Display of B
    return 0;
}
```
# Pure Virtual Function in C++
- In C++, a pure virtual function is a member function of the base class.
- It is used to provide a specific implementation in the derived class.
- It is used to provide a common interface to the base class and the derived class.
- It is used to provide a common interface to the parent class and the child class.
- It is used to provide a common interface to the super class and the sub class.
- It is used to provide a common interface to the general class and the specific class.
- It is used to achieve runtime polymorphism.
- It is used to achieve late binding.
```cpp
#include <iostream>
class A
{
public:
    virtual void display()=0; // Pure Virtual Function
};
class B : public A
{
public:
    void display() // Overriding
    {
        std::cout << "Display of B" << std::endl;
    }
};
int main()
{
    A* a = new B();
    a->display(); // Display of B
    return 0;
}
```
# Abstract Class in C++
- In C++, an abstract class is a class that contains at least one pure virtual function.
- It is used to provide a common interface to the base class and the derived class.
- It is used to provide a common interface to the parent class and the child class.
- It is used to provide a common interface to the super class and the sub class.
- It is used to provide a common interface to the general class and the specific class.
- It is used to achieve runtime polymorphism.
- It is mandatory to override the pure virtual function in the derived class.
```cpp
#include <iostream>
class A
{
public:
    virtual void display()=0; // Pure Virtual Function
};
class B : public A
{
public:
    void display() // Overriding
    {
        std::cout << "Display of B" << std::endl;
    }
};
int main()
{
    A* a = new B();
    a->display(); // Display of B
    return 0;
}
```

# Using Keyword in C++
- In C++, the `using` keyword is used to bring the base class members into the derived class scope.
- It is used to avoid the ambiguity in the derived class.
- It is used to bring the specific members of the base class into the derived class scope.

```cpp
#include <iostream>
class A
{
public:
    void display()
    {
        std::cout << "Display of A" << std::endl;
    }
};
class B : public A
{
public:
    using A::display; // Bringing the display of A into B
    void display(int x)
    {
        std::cout << "Display of B" << std::endl;
    }
};
int main()
{
    B b;
    b.display(); // Display of A
    b.display(10); // Display of B
    return 0;
}
```
```cpp
#include <iostream>
#include <vector>
using Container = std::vector<int>; // Using keyword
using Iterator = std::vector<int>::iterator; // Using keyword
int main()
{
    Container c = {1, 2, 3, 4, 5};
    for(Iterator it = c.begin(); it != c.end(); it++)
    {
        std::cout << *it << std::endl;
    }
    return 0;
}
```
# Enum Class in C++
- In C++, the `enum` keyword is used to define an enumeration.
- In C++11, a new way of defining an enumeration was introduced.
- It is called enum class.
- It is used to define a scoped enumeration.
- It is used to avoid the pollution of the enclosing scope.
- It is used to avoid the conflicts of the enumeration constants.

```cpp
#include <iostream>
enum class Color // Enum class
{
    Red,
    Green,
    Blue
};
int main()
{
    Color c = Color::Red;
    if(c == Color::Red)
    {
        std::cout << "Red" << std::endl;
    }
    return 0;
}
```
# Strongly Typed Enum in C++
- In C++11, a new way of defining an enumeration was introduced.
- It is called strongly typed enum.
- It is used to avoid the implicit conversion of the enumeration constants.
- It is used to avoid the conflicts of the enumeration constants.

```cpp
#include <iostream>
enum class Color : char // Strongly Typed Enum
{
    Red = 10,
    Green = 20,
    Blue = 30
};
int main()
{
    Color c = Color::Red;
    if(c == Color::Red)
    {
        std::cout << "Red" << std::endl;
    }
    return 0;
}
```
# Override and Final Specifiers in C++
- In C++11, two new specifiers were introduced.
- They are `override` and `final`.
- They are used to make the code more readable and maintainable.
- They are used to avoid the errors in the code.

```cpp
#include <iostream>
class A
{
    int x;
    int y;
public:
    virtual void display() override // Override Specifier
    {
        std::cout << "Display of A" << std::endl;
    }
};
class B : public A
{
public:
    void display() override // Override Specifier
    {
        std::cout << "Display of B" << std::endl;
    }
};
class C final // Final Specifier
{
};
// class D : public C // Error
// {
// };
int main()
{
    B b;
    b.display(); // Display of B
    return 0;
}
```
# Lambda Expressions in C++
- In C++11, a new way of defining a function was introduced.
- It is called lambda expression.
- It is used to define a function without a name.
- It is used to define a function at the place where it is called.
- Lambda functions behave like objects. They can be passed as arguments to other functions.
- They can capture the variables from the enclosing scope.
- All carry all the properties of a normal function and also of an object.

```cpp
#include <iostream>
int main()
{
    int x = 10;
    int y = 20;
    auto f = [x, y](int a, int b) -> int // Lambda Expression
    {
        return a + b + x + y;
    };
    std::cout << f(30, 40) << std::endl; // 100
    return 0;
}
```
# Lambda Capture in C++
- In C++11, a new way of capturing the variables was introduced.
- It is called lambda capture.
- It is used to capture the variables from the enclosing scope.
- It is used to pass the variables to the lambda function.
- It is used to modify the variables from the enclosing scope.

```cpp
#include <iostream>
int main()
{
    int x = 10;
    int y = 20;
    auto f = [&x, y](int a, int b) -> int // Lambda Capture
    {
        x++;
        return a + b + x + y;//x is passed by reference and y is passed by value also we can all the variables from the enclosing scope by reference by using [&]
        // we can also capture all the variables from the enclosing scope by value by using [=]
    };
    std::cout << f(30, 40) << std::endl; // 101
    std::cout << x << std::endl; // 11
    return 0;
}
```

# Exception Handling in C++
- In C++, exception handling is used to handle the runtime errors.
- It is used to separate the error handling code from the normal code.
- It is used to avoid the abnormal termination of the program.
- We can define our own exception classes and throw them by inheriting from the `std::exception` class.

```cpp
#include <iostream>
#include <exception>
class MyException: public std::exception // User Defined Exception
{
public:
    const char* what() const throw()
    {
        return "My Exception";
    }
};
int main()
{
    try
    {
        throw MyException();
    }
    catch(MyException& e)
    {
        std::cout << e.what() << std::endl;
    }
    catch(std::exception& e)
    {
        std::cout << e.what() << std::endl;
    }
    return 0;
}
```
# Auto Keyword in C++
- In C++11, a new keyword was introduced.
- It is called `auto`.
- It is used to automatically deduce the type of the variable.
- It is used to avoid the long and complex type names.
- It is used to make the code more readable and maintainable.

```cpp
#include <iostream>
int main()
{
    auto x = 10; // int
    auto y = 20.5; // double
    auto z = "Hello"; // const char*
    auto a = 10, b = 20.5, c = "Hello"; // Error
    std::cout << x << std::endl;
    std::cout << y << std::endl;
    std::cout << z << std::endl;
    return 0;
}
```
# Range-based For Loop in C++
- Range-base for loop is a new feature introduced in C++11.
- It is used to iterate over the elements of the container.
- It is used to make the code more readable and maintainable.
- It is used to avoid the use of iterators.

```cpp
#include <iostream>
#include <vector>
int main()
{
    std::vector<int> v = {10, 20, 30, 40, 50};
    for(auto i : v) // Range-based For Loop
    {
        std::cout << i << std::endl;
    }
    return 0;
}
```
# Smart Pointers in C++
- In C++, smart pointers are used to manage the memory.
- They are used to avoid the memory leaks.
- They are used to avoid the dangling pointers.
- They are used to avoid the explicit use of `new` and `delete` operators.
- They are used to make the code more readable and maintainable.
- They are used to avoid the explicit use of pointers.

```cpp
#include <iostream>
#include <memory>
class A
{
public:
    void display()
    {
        std::cout << "Display of A" << std::endl;
    }
};
int main()
{
    std::unique_ptr<A> p1(new A()); // Unique Pointer
    p1->display();
    std::shared_ptr<A> p2(new A()); // Shared Pointer
    p2->display();
    return 0;
}
```
## Unique Pointer
- It is used to manage the memory of the object.
- It is used to avoid the memory leaks.
- It is used to avoid the dangling pointers.
- It can be used in a single ownership model.
## Shared Pointer
- It is used to manage the memory of the object.
- It is used to avoid the memory leaks.
- It is used to avoid the dangling pointers.
- It can be used in a multiple ownership model, also called reference counting model.
- It is used to keep the count of the references to the object.
- It is used to delete the object when the count becomes zero.
## Weak Pointer
- It is used to avoid the circular references.
- It is used to avoid the memory leaks.
- It avoids the strong reference to the object.
- It is used to check whether the object is alive or not.
- It is used to convert the weak reference to the strong reference.

# Reference Wrappers in C++
- In C++, reference wrappers are used to wrap the references.
- They are used to avoid the ambiguity in the code.
- They are used to pass the references to the functions.
- They are used to pass the references to the algorithms.

```cpp
#include <iostream>
#include <functional>
void display(int& x)
{
    x++;
    std::cout << x << std::endl;
}
int main()
{
    int x = 10;
    std::reference_wrapper<int> rw = std::ref(x); // Reference Wrapper
    display(rw);
    return 0;
}
```
# Singleton Design Pattern in C++
- In C++, the singleton design pattern is used to create a single instance of the class.
- It is used to avoid the multiple instances of the class.
- It is used to avoid the global variables.
- It is used to provide a global point of access to the object.
- It is used to provide a single point of access to the object.

```cpp
#include <iostream>
class Singleton
{
    static Singleton* instance;
    Singleton()
    {
        std::cout << "Constructor" << std::endl;
    }
public:

    static Singleton* getInstance()
    {
        if(instance == nullptr)
        {
            instance = new Singleton();
        }
        return instance;
    }
    void display()
    {
        std::cout << "Display" << std::endl;
    }
};
Singleton* Singleton::instance = nullptr;
int main()
{
    Singleton* s1 = Singleton::getInstance();
    s1->display();
    Singleton* s2 = Singleton::getInstance();
    s2->display();
    return 0;
}
```
# Bind Function in C++
- In C++, the `bind` function is used to bind the arguments to the function.
- It is used to create a function object.
- It is used to create a function object with the arguments.
- It is used to create a function object with the placeholders.

```cpp

#include <iostream>
#include <functional>
void display(int x, int y)
{
    std::cout << x << " " << y << std::endl;
}
int main()
{
    auto f = std::bind(display, std::placeholders::_1, 20); // Bind Function
    f(10);
    return 0;
}
```

# Optional Class in C++
- In C++17, a new class was introduced.
- It is called `std::optional`.
- It is used to represent an optional object.
- It is used to avoid the null pointers.
- It is used to avoid the null references.
- It is used to avoid the null values.

```cpp
#include <iostream>
#include <optional>
std::optional<int> getValue()
{
    return 10;
}
int main()
{
    std::optional<int> x = getValue(); // Optional Class
    if(x.has_value())
    {
        std::cout << x.value() << std::endl;
    }
    return 0;
}
```
# Variant Class in C++
- In C++17, a new class was introduced.
- It is called `std::variant`.
- It is used to represent a type-safe union.
- It is used to avoid the null pointers.
- It is used to avoid the null references.
- It is used to avoid the null values.

```cpp
#include <iostream>
#include <variant>
int main()
{
    std::variant<int, float, std::string> v; // Variant Class
    v = 10;
    std::cout << std::get<int>(v) << std::endl;
    v = 20.5f;
    std::cout << std::get<float>(v) << std::endl;
    v = "Hello";
    std::cout << std::get<std::string>(v) << std::endl;
    return 0;
}
```
# If-Initalizer in C++
- In C++17, a new way of initializing the variables was introduced.
- It is called if-initializer.
- It is used to initialize the variables inside the if statement.
- It is used to make the code more readable, space-efficient and maintainable.

```cpp
#include <iostream>
bool display()
{
    std::cout << "Display" << std::endl;
    return true;
}
int main()
{
    if(auto x = display()) // If-Initializer
    {
        std::cout << x << std::endl;
    }
    return 0;
}
```
# Fold Expressions in C++
- In C++17, a new way of expanding the parameter pack was introduced.
- It is called fold expressions.
- It is used to expand the parameter pack.
- It is used to make the code more readable and maintainable.

```cpp
#include <iostream>
template<typename... Args>
auto sum(Args... args)
{
    return (args + ...); // Fold Expression
}
int main()
{
    std::cout << sum(10, 20, 30, 40, 50) << std::endl; // 150
    return 0;
}
```

# Thread Class in C++
- In C++, the `std::thread` class is used to create a new thread.
- It is used to execute the function in a separate thread.
- It is used to make the code more responsive and efficient.
- It is used to avoid the blocking of the main thread.

```cpp
#include <iostream>
#include <thread>
void display()
{
    std::cout << "Display" << std::endl;
}
int main()
{
    std::thread t1(display); // Thread Class
    t1.join();
    return 0;
}
```
# Mutex Class in C++
- In C++, the `std::mutex` class is used to protect the shared resources.
- It is used to create a critical section.
- It is used to avoid resource sharing conflicts.
- It is used to protect the shared resources from the access of multiple threads.

```cpp
#include <iostream>
#include <thread>
#include <mutex>
std::mutex m;
void display()
{
    m.lock(); // Lock
    for(int i = 0; i < 5; i++)
    {
        std::cout << "Display" << std::endl;
    }
    m.unlock(); // Unlock
}
int main()
{
    std::thread t1(display);
    std::thread t2(display);
    t1.join();
    t2.join();
    return 0;
}
```
# Condition Variable in C++
- In C++, the `std::condition_variable` class is used to synchronize the threads.
- It is used to avoid the busy waiting.
- It is used to make the code more responsive and efficient.
- It is used to avoid the blocking of the main thread.

```cpp
#include <iostream>
#include <thread>
#include <mutex>
#include <condition_variable>
std::mutex m;
std::condition_variable cv;
bool ready = false;
void display()
{
    std::unique_lock<std::mutex> ul(m);
    cv.wait(ul, []{return ready;});
    std::cout << "Display" << std::endl;
}
int main()
{
    std::thread t1(display);
    std::this_thread::sleep_for(std::chrono::seconds(2));
    {
        std::lock_guard<std::mutex> lg(m);
        ready = true;
    }
    cv.notify_one();
    t1.join();
    return 0;
}
```
# Future and Promise in C++
- In C++, the `std::future` class is used to get the result from the thread.
- It is used to make the code more responsive and efficient.
- It is used to avoid the blocking of the main thread.
- It is used to get the result from the thread.
- It is used to get the result from the asynchronous task.

```cpp
#include <iostream>
#include <thread>
#include <future>
int display()
{
    std::this_thread::sleep_for(std::chrono::seconds(2));
    return 10;
}
int main()
{
    std::future<int> f = std::async(display); // Future Class
    std::cout << f.get() << std::endl;
    return 0;
}
```
# STL_Algorithms in C++
- In C++, the Standard Template Library (STL) provides a rich set of algorithms.
- They are used to perform the operations on the containers.
- They are used to make the code more readable and maintainable.
- They are used to avoid the explicit use of loops.
- There are more than 100 algorithms in the STL like `sort`, `find`, `count`, `accumulate`, `transform`, `for_each`, `copy`, `remove`, `replace`, `reverse`, `rotate`, `unique`, `min`, `max`, `minmax`, `clamp`, `equal`, `mismatch`, `lexicographical_compare`, `is_permutation`, `next_permutation`, `prev_permutation`, `merge`, `includes`, `set_union`, `set_intersection`, `set_difference`, `set_symmetric_difference`, `nth_element`, `partial_sort`, `partial_sort_copy`, `is_sorted`, `is_heap`, `is_partitioned`, `is_permutation`, `is_sorted_until`, `is_heap_until`, `is_partitioned_until`, `is_permutation_until`, `search`, `find`, `find_if`, `find_if_not`, `find_end`, `find_first_of`, `adjacent_find`, `count`, `count_if`, `mismatch`, `equal`, `is_permutation`, `search_n`, `for_each`, `transform`, `generate`, `generate_n`, `remove`, `remove_if`, `remove_copy`, `remove_copy_if`, `replace`, `replace_if`, `replace_copy`, `replace_copy_if`, `swap`, `swap_ranges`, `iter_swap`, `reverse`, `reverse_copy`, `rotate`, `rotate_copy`, `random_shuffle`, `shuffle`, `sample`, `unique`, `unique_copy`, `is_partitioned`, `partition`, `stable_partition`, `partition_copy`, `partition_point`, `sort`, `stable_sort`, `partial_sort`, `partial_sort_copy`, `nth_element`, `lower_bound`, `upper_bound`, `binary_search`, `equal_range`, `merge`, `inplace_merge`, `includes`, `set_union`, `set_intersection`, `set_difference`, `set_symmetric_difference`, `push_heap`, `pop_heap`, `make_heap`, `sort_heap`, `is_heap`, `is_heap_until`, `min`, `max`, `minmax`, `min_element`, `max_element`, `minmax_element`, `lexicographical_compare`, `next_permutation`, `prev_permutation`, `clamp`, `iota`, `accumulate`, `inner_product`, `adjacent_difference`, `partial_sum`, `reduce`, `transform_reduce`, `exclusive_scan`, `inclusive_scan`, `transform_exclusive_scan`, `transform_inclusive_scan`, `sample`, `search`, 
`search_n`, `find`, `find_if`, `find_if_not`, `find_end`, `find_first_of`, `adjacent_find`, `count`, `count_if`, `mismatch`, `equal`, `is_permutation`, `search_n`, `for_each`, `transform`, `generate`, `generate_n`, `remove`, `remove_if`, `remove_copy`, `remove_copy_if`, `replace`, `replace_if`, `replace_copy`, `replace_copy_if`, `swap`, `swap_ranges`, `iter_swap`, `reverse`, `reverse_copy`, `rotate`, `rotate_copy`, `random_shuffle`, `shuffle`, `sample`, `unique`, `unique_copy`, `is_partitioned`, `partition`, `stable_partition`, `partition_copy`, `partition_point`, `sort`, `stable_sort`, `partial_sort`, `partial_sort_copy`, `nth_element`, `lower_bound`, `upper_bound`, `binary_search`, `equal_range`, `merge`, `inplace_merge`, `includes`, `set_union`, `set_intersection`, `set_difference`, `set_symmetric_difference`, `push_heap`, `pop_heap`, `make_heap`, `sort_heap`, `is_heap`, `is_heap_until`, `min`, `max`, `minmax`, `min_element`, `max_element`, `minmax_element`, `lexicographical_compare`, `next_permutation`, `prev_permutation`, `clamp`, `iota`, `accumulate`, `inner_product`, `adjacent_difference`, `partial_sum`, `reduce`, `transform_reduce`, `exclusive_scan`, `inclusive_scan`, `transform_exclusive_scan`, `transform_inclusive_scan`, `sample`, `search`, `search_n`, `find`, `find_if`, `find_if_not`, `find_end`, `find_first_of`, `adjacent_find`, `count`, `count_if`, `mismatch`, `equal`, `is_permutation`, `search_n`, `for_each`, `transform`, `generate`, `generate_n`, `remove`, `remove_if`, `remove_copy`, `remove_copy_if`, `replace`, `replace_if`, `replace_copy`, `replace_copy_if`, `swap`, `swap_ranges`, `iter_swap`, `reverse`, `reverse_copy`, `rotate`, `rotate_copy`, `random_shuffle`, `shuffle`, `sample`, `unique`, `unique_copy`, `is_partitioned`, `partition`, `stable_partition`,
`partition_copy`, `partition_point`, `sort`, `stable_sort`, `partial_sort`, `partial_sort_copy`, `nth_element`, `lower_bound`, `upper_bound`, `binary_search`, `equal_range`, `merge`, `inplace_merge`, `includes`, `set_union`, `set_intersection`, `set_difference`, `set_symmetric_difference`, `push_heap`, `pop_heap`, `make_heap`, `sort_heap`, `is_heap`, `is_heap_until`, `min`, `max`, `minmax`, `min_element`, `max_element`, `minmax_element`, `lexicographical_compare`, `next_permutation`, `prev_permutation`, `clamp`, `iota`, `accumulate`, `inner_product`, `adjacent_difference`, `partial_sum`, `reduce`, `transform_reduce`, `exclusive_scan`, `inclusive_scan`, `transform_exclusive_scan`, `transform_inclusive_scan`, `sample`, `search`, `search_n`, `find`, `find_if`, `find_if_not`, `find_end`, `find_first_of`, `adjacent_find`, `count`, `count_if`, `mismatch`, `equal`, `is_permutation`, `search_n`, `for_each`, `transform`, `generate`, `generate_n`, `remove`, `remove_if`, `remove_copy`, `remove_copy_if`, `replace`, `replace_if`, `replace_copy`, `replace_copy_if`, `swap`, `swap_ranges`, `iter_swap`, `reverse`, `reverse_copy`, `rotate`, `rotate_copy`, `random_shuffle`, `shuffle`, `sample`, `unique`, `unique_copy`, `is_partitioned`, `partition`, `stable_partition`, `partition_copy`, `partition_point`, `sort`, `stable_sort`, `partial_sort`, `partial_sort_copy`, `nth_element`, `lower_bound`, `upper_bound`, `binary_search`, `equal_range`, `merge`, `inplace_merge`, `includes`, `set_union`, `set_intersection`, `set_difference`, `set_symmetric_difference`, `push_heap`, `pop_heap`, `make_heap`, `sort_heap`, `is_heap`, `is_heap_until`, `min`, `max`, `minmax`, `min_element`, `max_element`, `minmax_element`, `lexicographical_compare`, `next_permutation`, `prev_permutation`, `clamp`, `iota`, `accumulate`, `inner_product` etc.
    
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
int main()
{
    std::vector<int> v = {10, 20, 30, 40, 50};
    std::for_each(v.begin(), v.end(), [](int x)
    {
        std::cout << x << std::endl;
    });
    std::sort(v.begin(), v.end());
    std::find(v.begin(), v.end(), 30);
    std::count(v.begin(), v.end(), 30);
    std::accumulate(v.begin(), v.end(), 0);
    std::transform(v.begin(), v.end(), v.begin(), [](int x)
    {
        return x * 2;
    });
    std::copy(v.begin(), v.end(), std::ostream_iterator<int>(std::cout, " "));
    std::remove(v.begin(), v.end(), 30);
    std::replace(v.begin(), v.end(), 30, 300);
    std::reverse(v.begin(), v.end());
    std::rotate(v.begin(), v.begin() + 2, v.end());
    std::unique(v.begin(), v.end());
    return 0;
}
```

# STL_Containers in C++
- In C++, the Standard Template Library (STL) provides a rich set of containers.
- They are used to store the data.
- They are used to make the code more readable and maintainable.
- They are used to avoid the explicit use of arrays.
- There are more than 10 containers in the STL like `array`, `vector`, `deque`, `list`, `forward_list`, `set`, `multiset`, `map`, `multimap`, `unordered_set`, `unordered_multiset`, `unordered_map`, `unordered_multimap`, `stack`, `queue`, `priority_queue`, `bitset`, `valarray`, `span`, `string`, `wstring`, `u16string`, `u32string`, `basic_string`, `basic_string_view`, `basic_stringbuf`, `basic_istringstream`, `basic_ostringstream`, `basic_stringstream`, `basic_filebuf`, `basic_ifstream`, `basic_ofstream`, `basic_fstream`, `basic_syncbuf`, `basic_osyncstream`, `basic_ostream`, `basic_istream`, `basic_iostream`, `basic_streambuf`, `basic_regex`, `basic_match_results`, `basic_regex_iterator`, `basic_regex_token_iterator`, `basic_ostream`, `basic_istream`, `basic_iostream`, `basic_streambuf`, `basic_regex`, `basic_match_results`, `basic_regex_iterator`, `basic_regex_token_iterator`, `basic_ostream`, `basic_istream`, `basic_iostream`, `basic_streambuf`, `basic_regex`, `basic_match_results`, `basic_regex_iterator`, `basic_regex_token_iterator`, `basic_ostream`, `basic_istream`, `basic_iostream`, `basic_streambuf`, `basic_regex`, `basic_match_results`, `basic_regex_iterator`, `basic_regex_token_iterator`, `basic_ostream`, `basic_istream`, `basic_iostream`, `basic_streambuf`, `basic_regex`, `basic_match_results`, `basic_regex_iterator`, `basic_regex_token_iterator`, `basic_ostream`, `basic_istream`, `basic_iostream`, `basic_streambuf`, `basic_regex`, `basic_match_results`, `basic_regex_iterator`, `basic_regex_token_iterator`, `basic_ostream`, `basic_istream`, `basic_iostream`, `basic_streambuf`, `basic_regex`, `basic_match_results`, `basic_regex_iterator`, `basic_regex_token_iterator`, `basic_ostream`, `basic_istream`, `basic_iostream`, `basic_streambuf`, `basic_regex`, `basic_match_results`, `basic_regex_iterator`, `basic_regex_token_iterator`, `basic_ostream`, `basic_istream`, `basic_iostream`, `basic_streambuf`, `basic_regex' etc.
    
```cpp
#include <iostream>
#include <vector>
#include <list>
#include <deque>
#include <set>
#include <map>
#include <unordered_set>
#include <unordered_map>
int main()
{
    std::vector<int> v = {10, 20, 30, 40, 50};
    std::list<int> l = {10, 20, 30, 40, 50};
    std::deque<int> d = {10, 20, 30, 40, 50};
    std::set<int> s = {10, 20, 30, 40, 50};
    std::map<int, std::string> m = {{10, "A"}, {20, "B"}, {30, "C"}, {40, "D"}, {50, "E"}};
    std::unordered_set<int> us = {10, 20, 30, 40, 50};
    std::unordered_map<int, std::string> um = {{10, "A"}, {20, "B"}, {30, "C"}, {40, "D"}, {50, "E"}};
    return 0;
}
```

# STL_Iterators in C++
- In C++, the Standard Template Library (STL) provides a rich set of iterators.
- They are used to iterate over the elements of the containers.
- They are used to make the code more readable and maintainable.
- They are used to avoid the explicit use of loops.
- There are more than 10 iterators in the STL like `input_iterator`, `output_iterator`, `forward_iterator`, `bidirectional_iterator`, `random_access_iterator`, `reverse_iterator`, `move_iterator`, `insert_iterator`, `front_insert_iterator`, `back_insert_iterator`, `istream_iterator`, `ostream_iterator`, `istreambuf_iterator`, `ostreambuf_iterator`, `iterator`, `reverse_iterator`, `move_iterator`, `insert_iterator`, `front_insert_iterator`, `back_insert_iterator`, `istream_iterator`, `ostream_iterator`, `istreambuf_iterator`, `ostreambuf_iterator`, `iterator`, `reverse_iterator`, `move_iterator`, `insert_iterator`, `front_insert_iterator`, `back_insert_iterator`, `istream_iterator`, `ostream_iterator`, `istreambuf_iterator`, `ostreambuf_iterator`, `iterator`, `reverse_iterator`, `move_iterator`, `insert_iterator`, `front_insert_iterator`, `back_insert_iterator`, `istream_iterator`, `ostream_iterator`, `istreambuf_iterator`, `ostreambuf_iterator`, `iterator`, `reverse_iterator`, `move_iterator`, `insert_iterator`, `front_insert_iterator`, `back_insert_iterator`, `istream_iterator`, `ostream_iterator`, `istreambuf_iterator`, `ostreambuf_iterator`, `iterator`, `reverse_iterator`, `move_iterator`, `insert_iterator`, `front_insert_iterator`, `back_insert_iterator`, `istream_iterator`, `ostream_iterator`, `istreambuf_iterator`, `ostreambuf_iterator`, `iterator`, `reverse_iterator`, `move_iterator`, `insert_iterator`, `front_insert_iterator`, `back_insert_iterator`, `istream_iterator`, `ostream_iterator`, `istreambuf_iterator`, `ostreambuf_iterator`, `iterator`, `reverse_iterator`, `move_iterator`, `insert_iterator`, `front_insert_iterator`, `back_insert_iterator`, `istream_iterator`, `ostream_iterator`, `istreambuf_iterator`, `ostreambuf_iterator`, `iterator`, `reverse_iterator`, `move_iterator`, `insert_iterator`, `front_insert_iterator`, `back_insert_iterator`, `istream_iterator`, `ostream_iterator`, `istreambuf_iterator`, `ostreambuf_iterator`, `iterator`, `reverse_iterator`, `move_iterator`, `insert_iterator`, `front_insert_iterator`, `back_insert_iterator`, `istream_iterator`, `ostream_iterator`, `istreambuf_iterator`, `ostreambuf_iterator`, `iterator`, `reverse_iterator`, `move_iterator`, `insert_iterator`, `front_insert_iterator`, `back_insert_iterator`, `istream_iterator`, `ostream_iterator`, `istreambuf_iterator` etc.
    
```cpp
#include <iostream>
#include <vector>
#include <iterator>
int main()
{
    std::vector<int> v = {10, 20, 30, 40, 50};
    std::vector<int>::iterator it = v.begin();
    std::advance(it, 2);
    std::cout << *it << std::endl;
    std::vector<int>::reverse_iterator rit = v.rbegin();
    std::cout << *rit << std::endl;
    std::vector<int>::const_iterator cit = v.cbegin();
    std::vector<int>::const_reverse_iterator crit = v.crbegin();
    std::vector<int>::const_iterator it1 = v.begin();
    std::vector<int>::const_iterator it2 = v.end();
    std::vector<int>::const_iterator it3 = v.cbegin();
    std::vector<int>::const_iterator it4 = v.cend();
    std::vector<int>::const_reverse_iterator rit1 = v.rbegin();
    std::vector<int>::const_reverse_iterator rit2 = v.rend();
    std::vector<int>::const_reverse_iterator rit3 = v.crbegin();
    std::vector<int>::const_reverse_iterator rit4 = v.crend();
    return 0;
}
```
# Future Error
- Future errors are used to caught those exceptions which are based on future and async functions.
- They also inherit from `std::exception` class
- We can define our own custom future exceptions by inheriting future error class.
- Setting up the future error constructor, we can create our own custom future exception.
```cpp
#include <iostream>
#ifndef EMPTYCONTAINER_HPP
#define EMPTYCONTAINER_HPP

#include <future>
#include <string>
class EmptyContainerException : public std::future_error
{
    std::string _msg;

public:
    virtual const char *what() const throw() override
    {
        return _msg.c_str();
    }
    EmptyContainerException() = delete;

    EmptyContainerException(const EmptyContainerException &) = delete; // disabled copy constructor

    EmptyContainerException(EmptyContainerException &&) = default; // disabled move constructor brand new in C++11

    EmptyContainerException &operator=(const EmptyContainerException &) = delete; // disabled assignment operator
    EmptyContainerException &operator=(EmptyContainerException &&) = delete;      // disabled assignment move operator brand new in C++11

    EmptyContainerException(std::string msg,std::future_errc futureerr) :future_error(futureerr),_msg{msg}
    {
       
    }

    
};
#endif // EMPTYCONTAINER_HPP

```

# Some STL Algorithms used most frequently
## std::copy
- It is used to copy the elements from one container to another container.
- It is used to make the code more readable and maintainable.
- It is used to avoid the explicit use of loops.
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
int main()
{
    std::vector<int> v1 = {10, 20, 30, 40, 50};
    std::vector<int> v2(5);
    std::copy(v1.begin(), v1.end(), v2.begin());
    for(auto i : v2)
    {
        std::cout << i << std::endl;
    }
    return 0;
}
```
## std::copy_if
- It is used to copy the elements from one container to another container based on the condition.
- It is used to make the code more readable and maintainable.
- It is used to avoid the explicit use of loops.
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
int main()
{
    std::vector<int> v1 = {10, 20, 30, 40, 50};
    std::vector<int> v2(5);
    std::copy_if(v1.begin(), v1.end(), v2.begin(), [](int x)
    {
        return x > 30;
    });
    for(auto i : v2)
    {
        std::cout << i << std::endl;
    }
    return 0;
}
```
## std::accumulate
- It is used to accumulate the elements of the container.
- We can use any operation to accumulate the elements.
- Mostly all operations are binary operations.
- By default, it uses the addition operation.
- It includes 3-4 arguments, first is the starting point, second is the ending point, third is the initial value and fourth is the operation.
- It is used to make the code more readable and maintainable.
```cpp
#include <iostream>
#include <vector>
#include <numeric>
int main()
{
    std::vector<int> v = {10, 20, 30, 40, 50};
    int result = std::accumulate(v.begin(), v.end(), 0, [](int x, int y)
    {
        return x + y;
    });
    std::cout << result << std::endl;
    return 0;
}
```
## std::transform
- It is used to transform the elements of the container.
- It can be used when we want to perform the operation on the elements of the container.
- All the changes are made in the same container.
- Also, we can use the different container for the output.
- It is used to make the code more readable and maintainable.
```cpp
//same container
#include <iostream>
#include <vector>
#include <algorithm>
int main()
{
    std::vector<int> v = {10, 20, 30, 40, 50};
    std::transform(v.begin(), v.end(), v.begin(), [](int x)
    {
        return x * 2;
    });
    for(auto i : v)
    {
        std::cout << i << std::endl;
    }
    return 0;
}
```
```cpp
//different container
#include <iostream>
#include <vector>
#include <algorithm>
int main()
{
    std::vector<int> v1 = {10, 20, 30, 40, 50};
    std::vector<int> v2(5);
    std::transform(v1.begin(), v1.end(), v2.begin(), [](int x)
    {
        return x * 2;
    });
    for(auto i : v2)
    {
        std::cout << i << std::endl;
    }
    return 0;
}
```
## std::all_of
- It is used to check whether all the elements of the container satisfy the condition.
- It returns true if all the elements satisfy the condition.
- It returns false if any of the elements does not satisfy the condition.
- We can use this algorithm to check the condition on all the elements of the container.
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
int main()
{
    std::vector<int> v = {10, 20, 30, 40, 50};
    if(std::all_of(v.begin(), v.end(), [](int x)
    {
        return x > 30;
    }))
    {
        std::cout << "All elements are greater than 30" << std::endl;
    }
    else
    {
        std::cout << "All elements are not greater than 30" << std::endl;
    }
    return 0;
}
```
## std::any_of
- It is used to check whether any of the elements of the container satisfy the condition.
- It returns true if any of the elements satisfy the condition.
- It returns false if none of the elements satisfy the condition.
- We can use this algorithm to check the condition on any of the elements of the container.
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
int main()
{
    std::vector<int> v = {10, 20, 30, 40, 50};
    if(std::any_of(v.begin(), v.end(), [](int x)
    {
        return x > 30;
    }))
    {
        std::cout << "At least one element is greater than 30" << std::endl;
    }
    else
    {
        std::cout << "No element is greater than 30" << std::endl;
    }
    return 0;
}
```
## std::none_of
- It is used to check whether none of the elements of the container satisfy the condition.
- It returns true if none of the elements satisfy the condition.
- It returns false if any of the elements satisfy the condition.
- We can use this algorithm to check the condition on none of the elements of the container.
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
int main()
{
    std::vector<int> v = {10, 20, 30, 40, 50};
    if(std::none_of(v.begin(), v.end(), [](int x)
    {
        return x > 30;
    }))
    {
        std::cout << "No element is greater than 30" << std::endl;
    }
    else
    {
        std::cout << "At least one element is greater than 30" << std::endl;
    }
    return 0;
}
```
## std::find
- It is used to find the first occurrence of the element in the container.
- It returns the iterator to the first occurrence of the element.
- It returns the iterator to the end if the element is not found.
- We can use this algorithm to find the first occurrence of the element in the container.
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
int main()
{
    std::vector<int> v = {10, 20, 30, 40, 50};
    auto it = std::find(v.begin(), v.end(), 30);
    if(it != v.end())
    {
        std::cout << "Element found at position " << it - v.begin() << std::endl;
    }
    else
    {
        std::cout << "Element not found" << std::endl;
    }
    return 0;
}
```
## std::find_if
- It is used to find the first occurrence of the element in the container based on the condition.
- It returns the iterator to the first occurrence of the element.
- It returns the iterator to the end if the element is not found.
- We can use this algorithm to find the first occurrence of the element in the container based on the condition.
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
int main()
{
    std::vector<int> v = {10, 20, 30, 40, 50};
    auto it = std::find_if(v.begin(), v.end(), [](int x)
    {
        return x > 30;
    });
    if(it != v.end())
    {
        std::cout << "Element found at position " << it - v.begin() << std::endl;
    }
    else
    {
        std::cout << "Element not found" << std::endl;
    }
    return 0;
}
```
## std::distance
- It is used to find the distance between two iterators.
- It returns the distance between two iterators.
- We can use this algorithm to find the distance between two iterators.
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
int main()
{
    std::vector<int> v = {10, 20, 30, 40, 50};
    auto it1 = v.begin();
    auto it2 = v.end();
    std::cout << std::distance(it1, it2) << std::endl;
    return 0;
}
```
## std::count
- It is used to count the occurrences of the element in the container.
- It returns the count of the occurrences of the element.
- We can use this algorithm to count the occurrences of the element in the container.
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
int main()
{
    std::vector<int> v = {10, 20, 30, 40, 50};
    std::cout << std::count(v.begin(), v.end(), 30) << std::endl;
    return 0;
}
```
## std::count_if
- It is used to count the occurrences of the element in the container based on the condition.
- It returns the count of the occurrences of the element.
- We can use this algorithm to count the occurrences of the element in the container based on the condition.
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
int main()
{
    std::vector<int> v = {10, 20, 30, 40, 50};
    std::cout << std::count_if(v.begin(), v.end(), [](int x)
    {
        return x > 30;
    }) << std::endl;
    return 0;
}
```
## std::max_element
- It is used to find the maximum element in the container.
- It returns the iterator to the maximum element.
- We can use this algorithm to find the maximum element in the container.
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
int main()
{
    std::vector<int> v = {10, 20, 30, 40, 50};
    auto it = std::max_element(v.begin(), v.end());
    std::cout << *it << std::endl;
    return 0;
}
```
## std::min_element
- It is used to find the minimum element in the container.
- It returns the iterator to the minimum element.
- We can use this algorithm to find the minimum element in the container.
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
int main()
{
    std::vector<int> v = {10, 20, 30, 40, 50};
    auto it = std::min_element(v.begin(), v.end());
    std::cout << *it << std::endl;
    return 0;
}
```
## std::minmax_element
- It is used to find the minimum and maximum element in the container.
- It returns the pair of iterators to the minimum and maximum element.
- We can use this algorithm to find the minimum and maximum element in the container.
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
int main()
{
    std::vector<int> v = {10, 20, 30, 40, 50};
    auto p = std::minmax_element(v.begin(), v.end());
    std::cout << *p.first << " " << *p.second << std::endl;
    return 0;
}
```

