# Modern CPP Training

## This is training code and material taught during the Modern CPP training in KPIT Technologies. This includes the following topics:
    - C++11
    - C++14
    - C++17

## Mainly, training focussed on the following topics:
    - Modern C++ features
    - STL
    - Multithreading
    - Smart Pointers
    - Exception Handling
    - Lambda Expressions
    - Regular Expressions
    - C++11/14/17 features

## Also, the training includes the following tools:
    - CMake
    - Google Test
    - Doxygen
    - Valgrind
    - GDB
    - Clang-Format
    - Clang-Tidy
    - CppCheck

# Constructor Delegation
- A constructor can call another constructor of the same class using the `this` pointer.
- This is called constructor delegation.
- It is useful when you want to provide default values for some parameters.

```cpp
#include <iostream>
class A
{
    int x;
    int y;
public:
    A(int x, int y) : x(x), y(y)
    {
        std::cout << "Parameterized Constructor" << std::endl;
    }
    A() : A(0, 0) // Delegating constructor
    {
        std::cout << "Default Constructor" << std::endl;
    }
};
int main()
{
    A a1(10, 20);
    A a2;
    return 0;
}
```
# Uniform Initialization in Modern C++
- In C++11, a new way of initializing objects was introduced.
- It is called uniform initialization.
- It uses curly braces to initialize objects.
- It is also called brace initialization.
- It is more consistent and prevents narrowing conversions.
- It is also used to initialize arrays and structures.

```cpp
#include <iostream>
class A
{
    int x;
    int y;
public:

    A(int x, int y) : x{x}, y{y} // Uniform Initialization
    {
        std::cout << "Parameterized Constructor" << std::endl;
    }
    A() : A{0, 0} // Delegating constructor
    {
        std::cout << "Default Constructor" << std::endl;
    }
};
int main()
{
    A a1{10, 20}; // Uniform Initialization
    A a2{}; // Uniform Initialization
    return 0;
}
```
# Special Member functions in C++
- Special member functions are the member functions that are automatically generated by the compiler if they are not explicitly defined.
- They are:
    - Default Constructor
    - Copy Constructor
    - Copy Assignment Operator
    - Destructor
    - Move Constructor
    - Move Assignment Operator
- These functions are generated by the compiler if they are not explicitly defined.
- They are generated based on the need of the class.
- We can explicitly define them if we want to customize their behavior.

````cpp
#include <iostream>
class A
{
    int x;
    int y;
public:
    A()=default; // Default Constructor
    A(const A&)=default; // Copy Constructor
    A& operator=(const A&)=default; // Copy Assignment Operator
    ~A()=default; // Destructor
    A(A&&)=default; // Move Constructor
    A& operator=(A&&)=default; // Move Assignment Operator
};
int main()
{
    A a1; // Default Constructor
    A a2(a1); // Copy Constructor
    A a3;
    a3=a2; // Copy Assignment Operator
    return 0;
}
````
# Delete Keyword in C++
- In C++, we can delete the special member functions using the `delete` keyword.
- It is used to explicitly delete the special member functions.
- It is used to prevent the compiler from generating the special member functions.
- It is used to prevent the objects of the class from being copied or assigned.

```cpp
#include <iostream>
class A
{
    int x;
    int y;
public:
    A()=delete; // Default Constructor
    A(const A&)=delete; // Copy Constructor
    A& operator=(const A&)=delete; // Copy Assignment Operator
    ~A()=delete; // Destructor
    A(A&&)=delete; // Move Constructor
    A& operator=(A&&)=delete; // Move Assignment Operator
};
int main()
{
    A a1; // Error
    A a2(a1); // Error
    A a3;
    a3=a2; // Error
    return 0;
}
```
# Using Keyword in C++
- In C++, the `using` keyword is used to bring the base class members into the derived class scope.
- It is used to avoid the ambiguity in the derived class.
- It is used to bring the specific members of the base class into the derived class scope.

```cpp
#include <iostream>
class A
{
public:
    void display()
    {
        std::cout << "Display of A" << std::endl;
    }
};
class B : public A
{
public:
    using A::display; // Bringing the display of A into B
    void display(int x)
    {
        std::cout << "Display of B" << std::endl;
    }
};
int main()
{
    B b;
    b.display(); // Display of A
    b.display(10); // Display of B
    return 0;
}
```
```cpp
#include <iostream>
#include <vector>
using Container = std::vector<int>; // Using keyword
using Iterator = std::vector<int>::iterator; // Using keyword
int main()
{
    Container c = {1, 2, 3, 4, 5};
    for(Iterator it = c.begin(); it != c.end(); it++)
    {
        std::cout << *it << std::endl;
    }
    return 0;
}
```
# Enum Class in C++
- In C++, the `enum` keyword is used to define an enumeration.
- In C++11, a new way of defining an enumeration was introduced.
- It is called enum class.
- It is used to define a scoped enumeration.
- It is used to avoid the pollution of the enclosing scope.
- It is used to avoid the conflicts of the enumeration constants.

```cpp
#include <iostream>
enum class Color // Enum class
{
    Red,
    Green,
    Blue
};
int main()
{
    Color c = Color::Red;
    if(c == Color::Red)
    {
        std::cout << "Red" << std::endl;
    }
    return 0;
}
```
# Strongly Typed Enum in C++
- In C++11, a new way of defining an enumeration was introduced.
- It is called strongly typed enum.
- It is used to avoid the implicit conversion of the enumeration constants.
- It is used to avoid the conflicts of the enumeration constants.

```cpp
#include <iostream>
enum class Color : char // Strongly Typed Enum
{
    Red = 10,
    Green = 20,
    Blue = 30
};
int main()
{
    Color c = Color::Red;
    if(c == Color::Red)
    {
        std::cout << "Red" << std::endl;
    }
    return 0;
}
```
# Override and Final Specifiers in C++
- In C++11, two new specifiers were introduced.
- They are `override` and `final`.
- They are used to make the code more readable and maintainable.
- They are used to avoid the errors in the code.

```cpp
#include <iostream>
class A
{
    int x;
    int y;
public:
    virtual void display() override // Override Specifier
    {
        std::cout << "Display of A" << std::endl;
    }
};
class B : public A
{
public:
    void display() override // Override Specifier
    {
        std::cout << "Display of B" << std::endl;
    }
};
class C final // Final Specifier
{
};
// class D : public C // Error
// {
// };
int main()
{
    B b;
    b.display(); // Display of B
    return 0;
}
```
# Lambda Expressions in C++
- In C++11, a new way of defining a function was introduced.
- It is called lambda expression.
- It is used to define a function without a name.
- It is used to define a function at the place where it is called.
- Lambda functions behave like objects. They can be passed as arguments to other functions.
- They can capture the variables from the enclosing scope.
- All carry all the properties of a normal function and also of an object.

```cpp
#include <iostream>
int main()
{
    int x = 10;
    int y = 20;
    auto f = [x, y](int a, int b) -> int // Lambda Expression
    {
        return a + b + x + y;
    };
    std::cout << f(30, 40) << std::endl; // 100
    return 0;
}
```
# Lambda Capture in C++
- In C++11, a new way of capturing the variables was introduced.
- It is called lambda capture.
- It is used to capture the variables from the enclosing scope.
- It is used to pass the variables to the lambda function.
- It is used to modify the variables from the enclosing scope.

```cpp
#include <iostream>
int main()
{
    int x = 10;
    int y = 20;
    auto f = [&x, y](int a, int b) -> int // Lambda Capture
    {
        x++;
        return a + b + x + y;//x is passed by reference and y is passed by value also we can all the variables from the enclosing scope by reference by using [&]
        // we can also capture all the variables from the enclosing scope by value by using [=]
    };
    std::cout << f(30, 40) << std::endl; // 101
    std::cout << x << std::endl; // 11
    return 0;
}
```

# Exception Handling in C++
- In C++, exception handling is used to handle the runtime errors.
- It is used to separate the error handling code from the normal code.
- It is used to avoid the abnormal termination of the program.
- We can define our own exception classes and throw them by inheriting from the `std::exception` class.

```cpp
#include <iostream>
#include <exception>
class MyException: public std::exception // User Defined Exception
{
public:
    const char* what() const throw()
    {
        return "My Exception";
    }
};
int main()
{
    try
    {
        throw MyException();
    }
    catch(MyException& e)
    {
        std::cout << e.what() << std::endl;
    }
    catch(std::exception& e)
    {
        std::cout << e.what() << std::endl;
    }
    return 0;
}
```
# Auto Keyword in C++
- In C++11, a new keyword was introduced.
- It is called `auto`.
- It is used to automatically deduce the type of the variable.
- It is used to avoid the long and complex type names.
- It is used to make the code more readable and maintainable.

```cpp
#include <iostream>
int main()
{
    auto x = 10; // int
    auto y = 20.5; // double
    auto z = "Hello"; // const char*
    auto a = 10, b = 20.5, c = "Hello"; // Error
    std::cout << x << std::endl;
    std::cout << y << std::endl;
    std::cout << z << std::endl;
    return 0;
}
```
# Range-based For Loop in C++
- Range-base for loop is a new feature introduced in C++11.
- It is used to iterate over the elements of the container.
- It is used to make the code more readable and maintainable.
- It is used to avoid the use of iterators.

```cpp
#include <iostream>
#include <vector>
int main()
{
    std::vector<int> v = {10, 20, 30, 40, 50};
    for(auto i : v) // Range-based For Loop
    {
        std::cout << i << std::endl;
    }
    return 0;
}
```
# Smart Pointers in C++
- In C++, smart pointers are used to manage the memory.
- They are used to avoid the memory leaks.
- They are used to avoid the dangling pointers.
- They are used to avoid the explicit use of `new` and `delete` operators.
- They are used to make the code more readable and maintainable.
- They are used to avoid the explicit use of pointers.

```cpp
#include <iostream>
#include <memory>
class A
{
public:
    void display()
    {
        std::cout << "Display of A" << std::endl;
    }
};
int main()
{
    std::unique_ptr<A> p1(new A()); // Unique Pointer
    p1->display();
    std::shared_ptr<A> p2(new A()); // Shared Pointer
    p2->display();
    return 0;
}
```
## Unique Pointer
- It is used to manage the memory of the object.
- It is used to avoid the memory leaks.
- It is used to avoid the dangling pointers.
- It can be used in a single ownership model.
## Shared Pointer
- It is used to manage the memory of the object.
- It is used to avoid the memory leaks.
- It is used to avoid the dangling pointers.
- It can be used in a multiple ownership model, also called reference counting model.
- It is used to keep the count of the references to the object.
- It is used to delete the object when the count becomes zero.
## Weak Pointer
- It is used to avoid the circular references.
- It is used to avoid the memory leaks.
- It avoids the strong reference to the object.
- It is used to check whether the object is alive or not.
- It is used to convert the weak reference to the strong reference.

# Reference Wrappers in C++
- In C++, reference wrappers are used to wrap the references.
- They are used to avoid the ambiguity in the code.
- They are used to pass the references to the functions.
- They are used to pass the references to the algorithms.

```cpp
#include <iostream>
#include <functional>
void display(int& x)
{
    x++;
    std::cout << x << std::endl;
}
int main()
{
    int x = 10;
    std::reference_wrapper<int> rw = std::ref(x); // Reference Wrapper
    display(rw);
    return 0;
}
```
# Singleton Design Pattern in C++
- In C++, the singleton design pattern is used to create a single instance of the class.
- It is used to avoid the multiple instances of the class.
- It is used to avoid the global variables.
- It is used to provide a global point of access to the object.
- It is used to provide a single point of access to the object.

```cpp
#include <iostream>
class Singleton
{
    static Singleton* instance;
    Singleton()
    {
        std::cout << "Constructor" << std::endl;
    }
public:

    static Singleton* getInstance()
    {
        if(instance == nullptr)
        {
            instance = new Singleton();
        }
        return instance;
    }
    void display()
    {
        std::cout << "Display" << std::endl;
    }
};
Singleton* Singleton::instance = nullptr;
int main()
{
    Singleton* s1 = Singleton::getInstance();
    s1->display();
    Singleton* s2 = Singleton::getInstance();
    s2->display();
    return 0;
}
```
# Bind Function in C++
- In C++, the `bind` function is used to bind the arguments to the function.
- It is used to create a function object.
- It is used to create a function object with the arguments.
- It is used to create a function object with the placeholders.

```cpp

#include <iostream>
#include <functional>
void display(int x, int y)
{
    std::cout << x << " " << y << std::endl;
}
int main()
{
    auto f = std::bind(display, std::placeholders::_1, 20); // Bind Function
    f(10);
    return 0;
}
```

# Optional Class in C++
- In C++17, a new class was introduced.
- It is called `std::optional`.
- It is used to represent an optional object.
- It is used to avoid the null pointers.
- It is used to avoid the null references.
- It is used to avoid the null values.

```cpp
#include <iostream>
#include <optional>
std::optional<int> getValue()
{
    return 10;
}
int main()
{
    std::optional<int> x = getValue(); // Optional Class
    if(x.has_value())
    {
        std::cout << x.value() << std::endl;
    }
    return 0;
}
```
# Variant Class in C++
- In C++17, a new class was introduced.
- It is called `std::variant`.
- It is used to represent a type-safe union.
- It is used to avoid the null pointers.
- It is used to avoid the null references.
- It is used to avoid the null values.

```cpp
#include <iostream>
#include <variant>
int main()
{
    std::variant<int, float, std::string> v; // Variant Class
    v = 10;
    std::cout << std::get<int>(v) << std::endl;
    v = 20.5f;
    std::cout << std::get<float>(v) << std::endl;
    v = "Hello";
    std::cout << std::get<std::string>(v) << std::endl;
    return 0;
}
```
# If-Initalizer in C++
- In C++17, a new way of initializing the variables was introduced.
- It is called if-initializer.
- It is used to initialize the variables inside the if statement.
- It is used to make the code more readable, space-efficient and maintainable.

```cpp
#include <iostream>
bool display()
{
    std::cout << "Display" << std::endl;
    return true;
}
int main()
{
    if(auto x = display()) // If-Initializer
    {
        std::cout << x << std::endl;
    }
    return 0;
}
```
# Fold Expressions in C++
- In C++17, a new way of expanding the parameter pack was introduced.
- It is called fold expressions.
- It is used to expand the parameter pack.
- It is used to make the code more readable and maintainable.

```cpp
#include <iostream>
template<typename... Args>
auto sum(Args... args)
{
    return (args + ...); // Fold Expression
}
int main()
{
    std::cout << sum(10, 20, 30, 40, 50) << std::endl; // 150
    return 0;
}
```

